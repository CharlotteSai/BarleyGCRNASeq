---
title: "GO_GCBarley_StableVersion"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(magrittr)
library(GO.db)
library(annotate)
library(parallel)
library(scales)
nCores <- min(detectCores() - 1, 12)
```

```{r collect GO for genes}
# the info of go term related to gene is coming along with reference genome and genome annotation of Morex v2 (2019)
go <- read_csv("BarleyAnnos/gene2GO.csv") %>% 
  dplyr::select(-TransID)

# attach go terms to each gene
gene2GO <- go %>%
  filter(!is.na(GO_terms)) %>%
  split(f = .$GeneID) %>%
  mclapply(function(x){
    unique(x$`GO_terms`)
  }, mc.cores = nCores)
# Remove any with no GO terms
gene2GO <- gene2GO[vapply(gene2GO, length, numeric(1)) > 0]
```

```{r build GO tree}
# Collect all the ancestor terms for each GO term
goAncestors <- c(
  as.list(GOBPANCESTOR),
  as.list(GOCCANCESTOR),
  as.list(GOMFANCESTOR)
)
# Define the Root nodes
rootGO <- list(
  BP = "GO:0008150",
  CC = "GO:0005575",
  MF = "GO:0003674"
)

gene2GO %<>% mclapply(function(x){
  unlist(goAncestors[x]) %>% # this expand each go along back to "all" node, but start with 1 step upper level
    unique %>%
    c(x) %>% # add the original gene2go for the gene
    setdiff(unlist(rootGO)) %>% # remove the very top level but give free level to choose with additional info in goSummaries
    setdiff("all") %>% 
    unique
}, mc.cores = nCores)

# Remove any with no GO terms again
gene2GO <- gene2GO[vapply(gene2GO, length, numeric(1)) > 0]

# prepare to check which gene(s) enrich to a given GO
go2Gene <- lapply(names(gene2GO), function(x){
  tibble(GeneID = x,
         GO = gene2GO[x] %>% unlist())
}) %>% bind_rows() %>% 
  distinct(GeneID,GO) %>%
  split(f = .$GO) %>%
  lapply(function(x){
    x[["GeneID"]]
  }) 

goSummaries <- url("https://uofabioinformaticshub.github.io/summaries2GO/data/goSummaries.RDS") %>%
  readRDS()
```

```{r DEgene enrich go}
#--------- DE gene summary ----------#
# load("~/Box/Bioinfo/BarleyGCRNASeq/DEGs_removeKont_S2.RData")
DEs %>% 
  lapply(function(de){
    tibble(n.de = length(de$GeneID),
           n.deWithGO = intersect(de$GeneID, names(gene2GO)) %>% length())
  })
#------------------------------------#
# $ABAde
# # A tibble: 1 x 2
#    n.de n.deWithGO
#   <int>      <int>
# 1  2042       2036
# 
# $GABAde
# # A tibble: 1 x 2
#    n.de n.deWithGO
#   <int>      <int>
# 1  2743       2735


goRes <- DEs %>% 
  lapply(function(treatDE){
    treatDE %>% 
      split(f = .$expression) %>% 
      lapply(function(de){
        DEgenes <- de$GeneID %>% intersect(names(gene2GO))
        deGenes2GO <- gene2GO[DEgenes]
        notDEGenes2GO <- gene2GO[setdiff(names(gene2GO), DEgenes)] 
        # genome wild protein coding gene except genes in the DEgenes as background
        nDE <- length(deGenes2GO)
        nNotDE <- length(notDEGenes2GO)
        
        NotdeGO <- unlist(notDEGenes2GO) %>% 
          table %>%
          as.data.frame() %>%
          set_names(c("GO_term", "notDECount")) 
        
        deGO <- unlist(deGenes2GO) %>% 
          table %>%
          as.data.frame() %>%
          set_names(c("GO_term", "DECount")) %>%
          left_join(NotdeGO, by = "GO_term") %>%
          as_tibble() %>%
          # filter(DECount > 1) %>% # filter de count more than 1 for each go terms
          # because this pre-filtering adj.p will not as tight as non pre-filtering 
          mutate(notDECount = ifelse(is.na(notDECount),0,notDECount)) %>% # avoid NA as a given GO associated gene all in DE 
          arrange(GO_term) %>%
          droplevels() 
          
        
        deGO %>%
          split(f = .$GO_term) %>%
          # extract(127) %>%
          lapply(function(df){
            mat <- matrix(c(df$DECount[1], df$notDECount[1],
                            nDE - df$DECount[1], nNotDE - df$notDECount[1]),
                          nrow = 2) %>% 
        set_colnames(c("Genes With GO Term", "Genes Without GO Term")) %>% 
        set_rownames(c("Genes of Interest", "Control Genes"))
            ft <- fisher.test(mat)
            mutate(df, 
                   N = sum(mat[,"Genes With GO Term"]),
                   Expected = nDE * df$notDECount[1] / nNotDE,
                   # number of de expected with proportion calculated in control set
                   p = ft$p.value)
          }) %>%
          bind_rows() %>%
          mutate(adjP = p.adjust(p, "bonferroni"),
                 FDR = p.adjust(p, "fdr"),
                 Description = Term(as.character(GO_term)),
                 expression = unique(de$expression)) %>%
          arrange(p) %>%
          left_join(goSummaries, by = c("GO_term" = "id")) %>%
          filter(DECount > Expected) %>% # consider the fisher test is two-sided
          dplyr::select(GO_term, Description, DECount, Expected, N, everything())
      }) %>% 
      bind_rows()
  })
```

```{r prepare go results}
goRes_filter <- names(goRes) %>% 
  lapply(function(x){
    goRes[[x]] %>% 
      mutate(Group = str_remove(x, "de")) %>% 
       dplyr::select(-notDECount)
  }) %>% 
  bind_rows() %>% 
  split(.$expression) %>% 
  lapply(function(x){
    x %>% 
      group_by(GO_term) %>% 
      filter(any(adjP <= 0.05 & shortest_path >= 4))
  }) %>% bind_rows()
```


```{r go heatmap}
# prepare p with direction
goHeat <- goRes_filter %>%
  mutate(
    p = ifelse(
      adjP <= 0.05, p, 1
    ),
    p = ifelse(
      expression == "Up", -log10(p), log10(p)
    )
  ) %>% 
  mutate(p = ifelse(
    (GO_term == "GO:0016301" | GO_term == "GO:0016773") & p == 0, 
    NA, p
  )) %>% # manually put significant but different regulation direction GO together
  na.omit()

paletteLength <- 100
myBreaks <- c(seq(min(goHeat$p), 0, 
                  length.out = ceiling(paletteLength/2) + 1), 
              seq(max(goHeat$p)/paletteLength, max(goHeat$p), length.out=floor(paletteLength/2)))
myColor <- colorRampPalette(c("blue", "white", "red"))(paletteLength)

goHeat %<>% 
      reshape2::dcast(GO_term + Description + ontology ~ Group,
                      value.var = "p") %>%
      mutate_all(~replace(., is.na(.), 0)) 
mapdata <- goHeat %>% 
  dplyr::select(ABA,GABA) %>% 
  set_rownames(rownames(goHeat))
Annos <- goHeat %>% 
  dplyr::select(ontology) %>% 
  set_rownames(rownames(goHeat))
GOnames <- goHeat$GO_term 
names(GOnames) <- rownames(goHeat)

# GO:0016301 and GO:0016773 present in both enrichment
pheatmap::pheatmap(mat = mapdata,
                   cluster_cols = FALSE,
                   annotation_row = Annos,
                   labels_row = GOnames,
                   # show_rownames = FALSE,
                   breaks = myBreaks,
                   color = myColor
) #-> GO_heat

# export
# export::graph2office(x = GO_heat, type = "ppt",
#              file = "GO_Res.pptx", width = 6,
#              aspectr = 1.4, append = TRUE)
```

```{r summary of GO}
goFinal <- goRes_filter %>% 
  filter(adjP <= 0.05) %>% 
  split(f = .$Group)

# GABA ABA share
go2Gene[["GO:0004553"]] # down
go2Gene[["GO:0016301"]] # opposite share
go2Gene[["GO:0016773"]] # opposite share

# ABA
go2Gene[["GO:0006468"]] # most sig down
go2Gene[["GO:0004722"]] # most sig up (only one)

# GABA
go2Gene[["GO:0046982"]] # most sig up
go2Gene[["GO:0004553"]] # most sig down (only one)

# save.image("~/Box/Bioinfo/BarleyGCRNASeq/GORes.RData")
```

```{r find potencial targets}
genePool <- DEs %>% 
  lapply(function(t){
    t %>% 
      split(f = .$expression)
  })
# for GO:0016301 - ABA.down and GABA.up
ABA_16301 <- intersect(go2Gene[["GO:0016301"]], genePool$ABAde$Down$GeneID)
GABA_16301 <- intersect(go2Gene[["GO:0016301"]], genePool$GABAde$Up$GeneID)
intersect(ABA_16301,GABA_16301)
# [1] "HORVU.MOREX.r2.2HG0084420" "HORVU.MOREX.r2.2HG0114190" "HORVU.MOREX.r2.7HG0565210"

# for GO:0016773 - ABA.down and GABA.up
ABA_16773 <- intersect(go2Gene[["GO:0016773"]], genePool$ABAde$Down$GeneID)
GABA_16773 <- intersect(go2Gene[["GO:0016773"]], genePool$GABAde$Up$GeneID)
intersect(ABA_16773,GABA_16773)
# [1] "HORVU.MOREX.r2.2HG0084420" "HORVU.MOREX.r2.2HG0114190" "HORVU.MOREX.r2.7HG0565210"
```
Two GO project same gene as `GO:0016773` is one level above `GO:0016301`. The `GO:0016301` is the direct related GO from the annotation. `GO:0016773` is the one bring to test as ancestor of some lower level GO.
```{r}
lapply(intersect(ABA_16301,GABA_16301), function(g){
  data <- filter(go, GeneID == g)
  data$GO_terms %>% 
    lapply(function(x){
      goAncestors[x] %>% 
        lapply(function(s){
          s %>% str_subset("GO:0016773")
        })
    })
})
```
`GO:0016773` is coming form `GO:0004672`from all three genes and `GO:0004674` gene1 and 3.
```{r find genes for these two GO}
# for GO:0004672 - ABA.down and GABA.up
ABA_4672 <- intersect(go2Gene[["GO:0004672"]], genePool$ABAde$Down$GeneID)
GABA_4672 <- intersect(go2Gene[["GO:0004672"]], genePool$GABAde$Up$GeneID)
intersect(ABA_4672,GABA_4672)

# for GO:0004674 - ABA.down and GABA.up
ABA_4674 <- intersect(go2Gene[["GO:0004674"]], genePool$ABAde$Down$GeneID)
GABA_4674 <- intersect(go2Gene[["GO:0004674"]], genePool$GABAde$Up$GeneID)
intersect(ABA_4674,GABA_4674)
```

```{r link to At}
AtHomo <- read_csv("./BarleyAnnos/Barley_Arabidopsis_Homolog.csv") %>% 
  mutate(ID = str_remove(ID, ".\\d$")) # 29515 barley to 14464 arabidopsis
```

```{r}
# logFC
DEs$ABAde %>% filter(GeneID %in% intersect(ABA_16301,GABA_16301))
DEs$GABAde %>% filter(GeneID %in% intersect(ABA_16301,GABA_16301))

# Associated GO
lapply(intersect(ABA_16301,GABA_16301), function(g){
  filter(go, GeneID == g) %>% 
    mutate(discription = Term(as.character(GO_terms))) %>% 
    dplyr::select(GeneID, everything()) %>% as.data.frame()
})

#AT homo
filter(AtHomo, ID %in% intersect(ABA_16301,GABA_16301)) %>% as.data.frame()
```

