---
title: "GO_GCBarley_StableVersion"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(magrittr)
library(GO.db)
library(annotate)
library(parallel)
library(scales)
nCores <- min(detectCores() - 1, 12)
```

```{r collect GO for genes}
# the info of go term related to gene is coming along with reference genome and genome annotation of Morex v2 (2019)
go <- read_csv("BarleyAnnos/gene2GO.csv") %>% 
  dplyr::select(-TransID)

# attach go terms to each gene
gene2GO <- go %>%
  filter(!is.na(GO_terms)) %>%
  split(f = .$GeneID) %>%
  mclapply(function(x){
    unique(x$`GO_terms`)
  }, mc.cores = nCores)
# Remove any with no GO terms
gene2GO <- gene2GO[vapply(gene2GO, length, numeric(1)) > 0]
```

```{r build GO tree}
# Collect all the ancestor terms for each GO term
goAncestors <- c(
  as.list(GOBPANCESTOR),
  as.list(GOCCANCESTOR),
  as.list(GOMFANCESTOR)
)
# Define the Root nodes
rootGO <- list(
  BP = "GO:0008150",
  CC = "GO:0005575",
  MF = "GO:0003674"
)

gene2GO %<>% mclapply(function(x){
  unlist(goAncestors[x]) %>% # this expand each go along back to "all" node, but start with 1 step upper level
    unique %>%
    c(x) %>% # add the original gene2go for the gene
    setdiff(unlist(rootGO)) %>% # remove the very top level but give free level yo choose with additional info in goSummaries
    setdiff("all") %>% 
    unique
}, mc.cores = nCores)

# Remove any with no GO terms again
gene2GO <- gene2GO[vapply(gene2GO, length, numeric(1)) > 0]

# prepare to check which gene(s) enrich to a given GO
go2Gene <- lapply(names(gene2GO), function(x){
  tibble(GeneID = x,
         GO = gene2GO[x] %>% unlist())
}) %>% bind_rows() %>% 
  distinct(GeneID,GO) %>%
  split(f = .$GO) %>%
  lapply(function(x){
    x[["GeneID"]]
  }) 

goSummaries <- url("https://uofabioinformaticshub.github.io/summaries2GO/data/goSummaries.RDS") %>%
  readRDS()
```

```{r DEgene enrich go}
#--------- DE gene summary ----------#
load("~/Box/Bioinfo/BarleyGCRNASeq/DEGs.RData")
DEs %>% 
  lapply(function(de){
    tibble(n.de = length(de$GeneID),
           n.deWithGO = intersect(de$GeneID, names(gene2GO)) %>% length())
  })
#------------------------------------#


goRes <- DEs %>% 
  lapply(function(treatDE){
    treatDE %>% 
      split(f = .$expression) %>% 
      lapply(function(de){
        DEgenes <- de$GeneID %>% intersect(names(gene2GO))
        deGenes2GO <- gene2GO[DEgenes]
        notDEGenes2GO <- gene2GO[setdiff(names(gene2GO), DEgenes)] 
        # genome wild protein coding gene except genes in the DEgenes as background
        nDE <- length(deGenes2GO)
        nNotDE <- length(notDEGenes2GO)
        
        NotdeGO <- unlist(notDEGenes2GO) %>% 
          table %>%
          as.data.frame() %>%
          set_names(c("GO_term", "notDECount")) 
        
        deGO <- unlist(deGenes2GO) %>% 
          table %>%
          as.data.frame() %>%
          set_names(c("GO_term", "DECount")) %>%
          left_join(NotdeGO, by = "GO_term") %>%
          as_tibble() %>%
          filter(DECount > 1) %>% # filter de count more than 1 for each go terms
          mutate(notDECount = ifelse(is.na(notDECount),0,notDECount)) %>% # avoid NA as a given GO associated gene all in DE 
          arrange(GO_term) %>%
          droplevels() 
          
        
        deGO %>%
          split(f = .$GO_term) %>%
          # extract(127) %>%
          lapply(function(df){
            mat <- matrix(c(df$DECount[1], df$notDECount[1],
                            nDE - df$DECount[1], nNotDE - df$notDECount[1]),
                          nrow = 2) %>% 
        set_colnames(c("Genes With GO Term", "Genes Without GO Term")) %>% 
        set_rownames(c("Genes of Interest", "Control Genes"))
            ft <- fisher.test(mat)
            mutate(df, 
                   N = sum(mat[,"Genes With GO Term"]),
                   Expected = nDE * df$notDECount[1] / nNotDE,
                   # number of de expected with proportion calculated in control set
                   p = ft$p.value)
          }) %>%
          bind_rows() %>%
          mutate(adjP = p.adjust(p, "bonferroni"),
                 FDR = p.adjust(p, "BY"),
                 Description = Term(as.character(GO_term)),
                 expression = unique(de$expression)) %>%
          arrange(p) %>%
          left_join(goSummaries, by = c("GO_term" = "id")) %>%
          filter(DECount > Expected) %>% # consider the t.test is two-sided
          dplyr::select(GO_term, Description, DECount, Expected, N, everything())
      }) %>% 
      bind_rows()
  })
```

```{r prepare go results}
goRes_filter <- names(goRes) %>% 
  lapply(function(x){
    goRes[[x]] %>% 
      mutate(Group = str_remove(x, "de")) %>% 
       dplyr::select(-notDECount)
  }) %>% 
  bind_rows() %>% 
  split(.$expression) %>% 
  lapply(function(x){
    x %>% 
      group_by(GO_term) %>% 
      filter(any(adjP < 0.05 & shortest_path >= 4)) %>% 
      filter(!(str_detect(Description,
                          "development|morphogenesis|cardioblast|cardiocyte|muscle|heart|animal|determination| cell |synapse")))
    # filter out animal organ related GO (not relevant)
  }) 
```


```{r go heatmap}
# prepare p with direction
goHeat <- goRes_filter %>%
  bind_rows() %>% 
  mutate(p = ifelse(adjP < 0.05, p, 1),
             p = ifelse(expression == "Up",-log10(p), log10(p))) 

paletteLength <- 100
myBreaks <- c(seq(min(goHeat$p), 0, 
                  length.out = ceiling(paletteLength/2) + 1), 
              seq(max(goHeat$p)/paletteLength, max(goHeat$p), length.out=floor(paletteLength/2)))
myColor <- colorRampPalette(c("blue", "white", "red"))(paletteLength)

goHeat %<>% 
      reshape2::dcast(GO_term + Description + expression + ontology ~ Group,
                      value.var = "p") %>%
      mutate_all(~replace(., is.na(.), 0)) 
mapdata <- goHeat %>% 
  dplyr::select(ABA,GABA) %>% 
  set_rownames(seq(1:length(.$ABA)))
Annos <- goHeat %>% 
  dplyr::select(ontology) %>% 
  set_rownames(seq(1:length(.$ontology)))

pheatmap::pheatmap(mat = mapdata,
                   cluster_cols = FALSE,
                   annotation_row = Annos,
                   show_rownames = FALSE,
                   breaks = myBreaks,
                   color = myColor
)  

# goHeat %>% 
#   with(
#     pheatmap::pheatmap(mat = tibble(ABA,GABA),
#                        cluster_cols = FALSE,
#                        annotation_row = Annos, 
#                        labels_row = GO_term,
#                        breaks = myBreaks,
#                        color = myColor
#                        )
#        )
```

```{r summary of GO}
goFinal <- goRes_filter %>% 
  bind_rows() %>% 
  filter(adjP < 0.05) %>% 
  split(f = .$Group)

# GABA ABA share
go2Gene[["GO:0004553"]] # down


# ABA
go2Gene[["GO:0005506"]] # both direction sig
go2Gene[["GO:0006468"]] # most sig down
go2Gene[["GO:0004722"]] # most sig down

# GABA
go2Gene[["GO:0046982"]] # most sig down
go2Gene[["GO:0045156"]] # most sig down
```

