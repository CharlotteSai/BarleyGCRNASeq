---
title: "GO_GCBarley_oldFashion"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(magrittr)
library(GO.db)
library(annotate)
library(parallel)
library(scales)
nCores <- min(detectCores() - 1, 12)
```

```{r collect GO for genes}
# the info of go term related to gene is coming along with reference genome and genome annotation of Morex v2 (2019)
go <- read_csv("BarleyAnnos/gene2GO.csv") %>% 
  dplyr::select(-TransID)

# attach go terms to each gene
gene2GO <- go %>%
  filter(!is.na(GO_terms)) %>%
  split(f = .$GeneID) %>%
  mclapply(function(x){
    unique(x$`GO_terms`)
  }, mc.cores = nCores)
# Remove any with no GO terms
gene2GO <- gene2GO[vapply(gene2GO, length, numeric(1)) > 0]

# attach gene with each go term for later track direct go back to genes
go2Gene_original <- lapply(names(gene2GO), function(x){
  tibble(GeneID = x,
         GO = gene2GO[x] %>% unlist())
}) %>% bind_rows() %>% 
  distinct(GeneID,GO) %>%
  split(f = .$GO) %>%
  lapply(function(x){
    x[["GeneID"]]
  }) 
```

```{r build GO tree}
# Collect all the ancestor terms for each GO term
goAncestors <- c(
  as.list(GOBPANCESTOR),
  as.list(GOCCANCESTOR),
  as.list(GOMFANCESTOR)
)
# Define the Root nodes
rootGO <- list(
  BP = "GO:0008150",
  CC = "GO:0005575",
  MF = "GO:0003674"
)
# # Define the terms with <= 1 step back to the root nodes
# firstLevelGO <- list(
#   BP = c(rootGO$BP, get(rootGO$BP, GOBPCHILDREN)),
#   CC = c(rootGO$CC, get(rootGO$CC, GOCCCHILDREN)),
#   MF = c(rootGO$MF, get(rootGO$MF, GOMFCHILDREN))
# ) %>%
#   lapply(unique)
# # Define the terms with <= 2 steps back to the root nodes
# secondLevelGO <- list(
#   BP = c(firstLevelGO$BP, lapply(firstLevelGO$BP, get, GOBPCHILDREN)),
#   CC = c(firstLevelGO$CC, lapply(firstLevelGO$CC, get, GOCCCHILDREN)),
#   MF = c(firstLevelGO$MF, lapply(firstLevelGO$MF, get, GOMFCHILDREN))
# ) %>%
#   lapply(unlist) %>%
#   lapply(unique) %>%
#   lapply(function(x){x[!is.na(x)]})
# # Define the terms with <= 3 steps back to the root nodes
# thirdLevelGO <- list(
#   BP = c(secondLevelGO$BP, lapply(secondLevelGO$BP, get, GOBPCHILDREN)),
#   CC = c(secondLevelGO$CC, lapply(secondLevelGO$CC, get, GOCCCHILDREN)),
#   MF = c(secondLevelGO$MF, lapply(secondLevelGO$MF, get, GOMFCHILDREN))
# ) %>%
#   mclapply(unlist, mc.cores = nCores) %>%
#   mclapply(unique, mc.cores = nCores) %>%
#   mclapply(function(x){x[!is.na(x)]}, mc.cores = nCores)
# Expand so each gene now has all parent terms correctly assigned and also removing GO terms which are 3rd level or below
gene2GO %<>% mclapply(function(x){
  unlist(goAncestors[x]) %>% # this expand each go along back to "all" node,but start with 1 step upper level
    unique %>%
    c(x) %>% # add the original gene2go for the gene
    setdiff(unlist(rootGO)) %>% # remove the very top level but give free level yo choose with additional info in goSummaries 
    # setdiff(unlist(thirdLevelGO)) %>% # This is now one step deeper into the go terms
    # setdiff(unlist(secondLevelGO)) %>%  # This is the original method
    setdiff("all") %>% 
    unique
}, mc.cores = nCores)
# Remove any with no GO terms again
gene2GO <- gene2GO[vapply(gene2GO, length, numeric(1)) > 0]

# prepare to check which gene(s) enrich to a given GO
go2Gene <- lapply(names(gene2GO), function(x){
  tibble(GeneID = x,
         GO = gene2GO[x] %>% unlist())
}) %>% bind_rows() %>% 
  distinct(GeneID,GO) %>%
  split(f = .$GO) %>%
  lapply(function(x){
    x[["GeneID"]]
  }) 

goSummaries <- url("https://uofabioinformaticshub.github.io/summaries2GO/data/goSummaries.RDS") %>%
  readRDS()
```

```{r DEgene enrich go}
#--------- DE gene summary ----------#
DEs %>% 
  lapply(function(de){
    tibble(n.de = length(de$GeneID),
           n.deWithGO = intersect(de$GeneID, names(gene2GO)) %>% length())
  })
#------------------------------------#


goRes <- DEs %>% 
  lapply(function(treatDE){
    treatDE %>% 
      split(f = .$expression) %>% 
      lapply(function(de){
        DEgenes <- de$GeneID
        deGenes2GO <- gene2GO[DEgenes]
        notDEGenes2GO <- gene2GO[setdiff(names(gene2GO), DEgenes)] 
        # genome wild protein coding gene except genes in the DEgenes as background
        nDE <- length(deGenes2GO)
        nNotDE <- length(notDEGenes2GO)
        
        
        deGO <- unlist(deGenes2GO) %>% 
          table %>%
          as.data.frame() %>%
          set_names(c("GO_term", "DECount")) %>%
          mutate(notDECount = table(unlist(notDEGenes2GO))[GO_term],
                 notDECount = as.vector(notDECount)) %>%
          as_tibble() %>%
          filter(DECount > 1) %>% # filter de count more than 1 for each go terms
          arrange(GO_term) %>%
          droplevels() 
          
        
        deGO %>%
          split(f = .$GO_term) %>%
          lapply(function(df){
            mat <- matrix(c(df$DECount[1], df$notDECount[1],
                            nDE - df$DECount[1], nNotDE - df$notDECount[1]),
                          nrow = 2) %>% 
        set_colnames(c("Genes With GO Term", "Genes Without GO Term")) %>% 
        set_rownames(c("Genes of Interest", "Control Genes"))
            ft <- fisher.test(mat)
            mutate(df, 
                   N = sum(mat[,"Genes With GO Term"]),
                   Expected = nDE * df$notDECount[1] / nNotDE,
                   # number of de expected with proportion calculated in control set
                   p = ft$p.value)
          }) %>%
          bind_rows() %>%
          mutate(adjP = p.adjust(p, "bonferroni"),
                 FDR = p.adjust(p, "BY"),
                 Description = Term(as.character(GO_term)),
                 expression = unique(de$expression)) %>%
          arrange(p) %>%
          left_join(goSummaries, by = c("GO_term" = "id")) %>%
          filter(DECount > Expected) %>% # consider the t.test is two-sided
          dplyr::select(GO_term, Description, DECount, Expected, N, everything())
      }) %>% 
      bind_rows()
  })
```

```{r prepare go results}
goRes_filter <- names(goRes) %>% 
  lapply(function(x){
    goRes[[x]] %>% 
      mutate(Group = str_remove(x, "de")) %>% 
       dplyr::select(-notDECount)
  }) %>% 
  bind_rows() %>% 
  split(.$expression) %>% 
  lapply(function(x){
    x %>% 
      group_by(GO_term) %>% 
      filter(any(adjP < 0.01 & shortest_path >= 4))
  })

goFunSplit <- goRes_filter %>% 
  lapply(function(x){
    commonSig <- x %>%
      reshape2::dcast(GO_term + Description + expression + ontology ~ Group, 
                      value.var = "adjP") %>%
      mutate_all(~replace(., is.na(.), 1)) %>% 
      filter(ABA < 0.01 & GABA < 0.01) %>% 
      mutate(tag = "shared GO") %>% 
      arrange(GABA) %>% 
      split(.$ontology)
    
    spSig <- x %>%
      reshape2::dcast(GO_term + Description + expression + ontology ~ Group, 
                      value.var = "adjP") %>%
      mutate_all(~replace(., is.na(.), 1)) %>% 
      filter((ABA < 0.01 & GABA >= 0.01) | (ABA >= 0.01 & GABA < 0.01)) %>% 
      mutate(tag = "special in one") %>% 
      arrange(GABA) %>% 
      split(.$ontology)
    list(common = commonSig,
         special = spSig)
  })
```

